<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>PyDCG</title>

    <link rel="stylesheet" href="stylesheets/styles2.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <!--<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>-->
    <![endif]-->
	<script type="text/javascript"
	src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
	
	
  </head>
  
  
  <body id="pub">
    <div id="wrapper">
	  <div id="title">
		<img src="logo.png">
        <h1> PyDCG </h1>
		<h2>(Python's Discrete and Combinatorial Geometry Library)</h2>
	  </div>
	  
	  <div id="mainNav">
		<ul>
		  <li><a href="index.html" id="indexLink">Home</a></li>
		  <li><a href="doc.html" id="docLink">Documentation</a> </li>
		  <li><a href="pub.html" id="pubLink">Publications</a> </li>
		  <li><a href="contrib.html" id="contribLink">Contributors </a></li>
		</ul>
		<div id="down">
		<ul>
          <li><a href="https://github.com/rfabila/PyDCG/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/rfabila/PyDCG/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/rfabila/PyDCG">View On <strong>GitHub</strong></a></li>
        </ul>
		</div>
		<footer>
        <p>This project is maintained by <a href="https://github.com/rfabila">rfabila</a> and <a href="https://github.com/csaorl">csaorl</a></p>
        
      </footer>
	  </div>
<div id="content">
<p>Here are the publications related to PyDCG by their respective module.

  <ul>
	<li><b>crossing</b></li>
	<p>Let \( S \) be a set of \( n \) points in the plane. Join every pair of points with a line segment and
	count the number of pairs of segments that cross. This is the
	<i><a href="http://mathworld.wolfram.com/RectilinearCrossingNumber.html">rectilinear crossing number</a></i>
	of \( S \).
	Let \( \overline{cr}(n) \) be the minimum of this value over all sets of
	\( n \) points in
	general position in the plane.
	The <a href="http://www.ist.tugraz.at/aichholzer/research/rp/triangulations/crossing/">
	rectilinear crossing number project page</a>, keeps track of the progress in determining
    the rectilinar crossing number.
	PyDCG has a crossing module that contains various functions
	for playing with the rectilinear crossing number. </p>
	<ul>
	  <li><a href=h2ttp://jgaa.info/getPaper?id=328">Computational search of small point sets
	  with small rectilinear crossing number.</a>
	  <i>Ruy Fabila-Monroy and Jorge Lopez.</i></li>
	  <p> In that paper we used the crossing module to find set of 75 points with only 450492 crossings.
	  There exists a <a href="http://arxiv.org/abs/0805.0016">construction </a> that given a point
	  set with few
	  crossing creates larger and larger sets with few crossings. With our set of 75 points
		were able to break the asymptotic upper bound. As of today,
		it stands at \( \overline{cr}(n) \le 0.380473 \binom{n}{4}+\Theta (n^3) \).</p>
	  <li><a href="files/frank.pdf">Algoritmo amortizado para el número de cruces rectilíneos
	  sobre gráficas completas (in Spanish).</a></li>
	  <i> Frank Duque.</i>
	  <p>
	  Frank's Master's thesis. It details an algorithm that receives a set of \(n\) points
	  \(S\), a point \(q \in S \), and a set \(C\) of \(m\) candidate points.
	  The algorithm computes the crossing number of
	  \( S-q+p\) for each \(p \in C \) in \(O((n+m)^2)\) (actually the implementation
	  runs in \(O((n+m)^2 \log (n+m))\) time). If \(m=\Theta(n)\) this is \(O(n)\) per candidate
	  point. The idea was to find a "good" replacement for \(q\) in order to improve the crossing
	  number of \(S\). We found a lot of new sets but none was good enough to give a new asymptotic
	  upper bound. The thesis also contains an algorithm that computes the crossing number
	  of every set of the form \(S-p\) with \(p \in S\) in \(O(n^2)\) total time
	  (again the implementation runs in \(O(n^2 \log n)\) time); the idea is to use this algorithm
	  to use a good set to find good smaller sets. Both algorithms are in the crossing module.</p>
	</ul>
    <li><b>holes</b></li>
	<p>
	  An \(r\)-hole of \(S\) is a subset \(H\) of \(S\), of \(r\) points,
	  that is in convex position and contains
	  no other point of \(S\) in its convex hull. Holes are related to the
	  <a href="http://en.wikipedia.org/wiki/Happy_ending_problem">Happy Ending Problem.</a>
	  </p>
	  <ul>
		<li>
		  <a href="https://www.cs.princeton.edu/research/techreps/TR-153-88">
			Searching for Empty Convex Polygons.</a>
		  <i>David P. Dobkin, Herbert Edelsbrunner and Mark H. Overmars</i>
		  <p>In that paper the authors give an algorithm to compute the number of \(r\)-holes
		  in a given point set in time proportional to the number of these holes.
		</li>
		<li>
		<a href="files/carlos.pdf">Un algoritmo para contar polígonos convexos
		vacíos en conjuntos de puntos en el plano (in Spanish).</a></li>
		<i>Carlos Hidalgo-Toscano.</i>
		<p><a href="https://github.com/csaorl">Carlos's</a> Bachelor's thesis; it details
		  the implementation of the above algorithm. The following algorithm
		  is also described: given a point \(q\) not in \(S\)
		and a point \(p\) computes the number of holes in \(S-p+q\). This is done
		in time proportional to the number of holes that contain \(p\) and \(q\).
		Both algorithms are implemented in the holes module.</p>
	  </ul>
  <li><b>points</b></li>
  <p>This module implements various point set generators. It also gives wrappers to
  the <a href="http://www.ist.tugraz.at/aichholzer/research/rp/triangulations/ordertypes/">Order
  Type Database.</a></p>
  <ul>
	<li><a href="http://link.springer.com/article/10.1023%2FA%3A1021231927255">
	Enumerating order types for small point sets with applications.</a>
	O. Aichholzer, F. Aurenhammer, and H. Krasser. </li>
	<p>The order type is a notion of combinatorial equivalence of point sets. The order
	type database contains a representative of each equivalence class for \( n=1,\dots,11 \).
	The points module provides acces to this database.</p>
	
	<li><a href="http://arxiv.org/abs/1305.6693"> Drawing the double circle on
	a grid of minimum size.</a>
	<i>Sergey Bereg, Ruy Fabila-Monroy, David Flores-Peñaloza, Mario Lopez, Pablo Pérez-Lantero</i>
	
	<p>We describe an algorithm to generate the double circle; it runs in linear time. This generator
	  is available in the points module.</p>
	</li>
  </ul>
  </ul>
  </p>

</div>
	</div>
  </body>
</html>
      



   
